// src/main.rs\n\nuse jsonwebtoken::{encode, EncodingKey, Header};\nuse rsa::{RsaPrivateKey, RsaPublicKey};\nuse std::time::{Duration, SystemTime, UNIX_EPOCH};\nuse warp::Filter;\n\n#[derive(Debug, Serialize)]\nstruct Jwk {\n    kty: String,\n    n: String,\n    e: String,\n    use_: String,\n    kid: String,\n}\n\nfn generate_keys() -> (RsaPrivateKey, RsaPublicKey) {\n    let bits = 2048;\n    let private_key = RsaPrivateKey::new(&mut rand::thread_rng(), bits).expect("Failed to generate a key");\n    let public_key = RsaPublicKey::from(&private_key);\n    (private_key, public_key)\n}\n\nfn create_jwt(private_key: &RsaPrivateKey, user_id: &str) -> String {\n    let header = Header::new(jsonwebtoken::Algorithm::RS256);\n    let claims = Claims {\n        sub: user_id.to_owned(),\n        exp: (SystemTime::now() + Duration::from_secs(3600)).duration_since(UNIX_EPOCH).unwrap().as_secs(),\n    };\n    \n    encode(&header, &claims, &EncodingKey::from_rsa_pem(&private_key.to_pem().unwrap()).unwrap()).unwrap()\n}\n\nasync fn jwks_endpoint(public_key: &RsaPublicKey) -> impl warp::Reply {\n    let jwk = Jwk {\n        kty: "RSA".to_string(),\n        n: base64::encode(&public_key.to_pkcs1().unwrap()),\n        e: base64::encode(&public_key.e().to_vec()),\n        use_: "sig".to_string(),\n        kid: "key-id".to_string(),\n    };\n    warp::reply::json(&jwk)\n}\n\n#[tokio::main]\nasync fn main() {\n    let (private_key, public_key) = generate_keys();\n    \n    let jwks = warp::path("jwks.json")\n        .and_then(move || jwks_endpoint(&public_key));\n\n    println!("Server running on http://localhost:3030");\n    warp::serve(jwks).run(([127, 0, 0, 1], 3030)).await;\n}\n\n#[derive(Debug, Serialize)]\nstruct Claims {\n    sub: String,\n    exp: u64,\n}